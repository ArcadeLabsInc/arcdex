<?php

namespace App\Http\Controllers;

use App\Exceptions\ProofException;
use App\Models\Nonce;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Elliptic\EC;
// use phpseclib3\Crypt\EC;
// use phpseclib3\Crypt\PublicKeyLoader;
// use phpseclib3\Math\BigInteger;
// use phpseclib3\Crypt\EC\Curves\Secg\Secp256k1;
// use phpseclib3\Crypt\EC\Curves\secp256k1 as CurvesSecp256k1;
// use phpseclib3\Crypt\EC\Point;
// use phpseclib3\Crypt\EC\PublicKey;

class LoginController extends Controller
{
    // render login page via inertia
    public function index()
    {
        return Inertia::render('Login');
    }

    public function nonce(Request $request)
    {
        try {
            $request->validate([
                'pubkey' => 'required',
                'device_name' => 'required',
            ]);
        } catch (\Exception $e) {
            throw ValidationException::withMessages([
                'missing' => 'Missing required fields',
            ]);
        }

        $nonce = bin2hex(random_bytes(32));

        Nonce::create([
            'nonce' => $nonce,
            'pubkey' => $request->pubkey,
            'device_name' => $request->device_name
        ]);

        return [
            'nonce' => $nonce
        ];
    }

    public function apiLogin(Request $request)
    {
        try {
            $request->validate([
                'pubkey' => 'required',
                'device_name' => 'required',
                'proof' => 'required',
                'nonce' => 'required',
            ]);
        } catch (\Exception $e) {
            throw ValidationException::withMessages([
                'missing' => 'Missing required fields',
            ]);
        }

        // $nonce = $request->input('nonce');
        // TODO: Verify this nonce matches the nonce and associated data in our db table

        // Validate the proof was generated by the private key associated with the pubkey
        try {
            $pubkey = $request->input('pubkey');
            // $pubkey = "0439d49a8a7cda1da43816d01c3a3a3b0c878baf181aaee34a9b0d846f37929c42115a70d7c1456d5e6c2e80e90850a7f9b9023b6fddc59b5d7997d153b05188e6";

            $ec = new EC('secp256k1');
            $key = $ec->keyFromPublic($pubkey, 'hex');

            $hash = $request->input('hash');
            $signature = $request->input('proof');
            $verified = ($key->verify($hash, $signature) == TRUE) ? "true" : "false";

            return response()->json([
                'pubkey' => $pubkey,
                'key' => $key->inspect(),
                'verified' => $verified,
            ]);

            // $math = new BigInteger();
            // $publicKey = new PublicKey($math, [
            //     'curve' => new CurvesSecp256k1(),
            //     'point' => new Point(
            //         $math,
            //         new BigInteger($pubkey, 16),
            //         new BigInteger('7')
            //     )
            // ]);

            // $x = $math->
            // $xCoord = new BigInteger($pubkey, 16);
            // $secp = new CurvesSecp256k1();
            // $modulus = $secp->getModulus();
            // $yCoord = $xCoord->pow(3)->add(new BigInteger('7'))->modPow($modulus->add(new BigInteger('1'))->divide(new BigInteger('4')), $modulus);
            // $point = new Point($xCoord, $yCoord);
            // $publicKey = new PublicKey($point);



            // $pubkeyinput = "0439d49a8a7cda1da43816d01c3a3a3b0c878baf181aaee34a9b0d846f37929c42115a70d7c1456d5e6c2e80e90850a7f9b9023b6fddc59b5d7997d153b05188e6";

            // $pubkey = "-----BEGIN PUBLIC KEY-----\n" . wordwrap($pubkeyinput, 64, "\n", true) . "\n-----END PUBLIC KEY-----\n";
            // $key = EC::loadPublicKey($pubkey);
            // return response()->json([
            //     'token' => 'asdfasdf',
            //     // 'demosig' => $key->verify($request->input('hash'), $request->input('proof')),
            //     'pubkey' => $pubkey,
            // ]);

            // $pubkeyinput = $request->input('pubkey');
            // $key = PublicKeyLoader::load($pubkey);
            // Get the public key from the app
            // $publicKey = $request->input('pubkey');

            // $expected = '-----BEGIN PUBLIC KEY-----
            // MCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=
            // -----END PUBLIC KEY-----';

            // 73fd1e67ef2155429f908247be047d500a75b70fe73bbd0130a8312a35b447e7

            // Log::error($publicKey);

            // $key = (new EC('secp256k1'))->loadPublicKey($publicKey);
            // $public = EC::loadPublicKey($publicKey);

            // $testo = PublicKeyLoader::load
            // $public = EC::loadFormat('secp256k1', $publicKey);


            // $public = EC::createKey('secp256k1')->getPublicKey();


            // $private = EC::createKey('secp256k1');
            // $public = $private->getPublicKey();

            // $plaintext = 'terrafrost';

            // $signature = $private->sign($plaintext);
            // $verified = $public->verify($hash, $signature) ? 'verified' : 'unverified';



            // return response()->json([
            //     'token' => 'asdfasdf',
            //     'demosig' => $verified
            // ]);

            // Verify the signature
            // $message = 'Hello world';
            // $signature = $request->input('proof');
            // $signatureBuffer = hex2bin($signature);

            // $ec = new EC('secp256k1');
            // $ec->loadPublicKey($publicKey);
            // $isVerified = $ec->verify($message, $signatureBuffer);

            // Define the public key hex
            // $public_key_hex = "0439d49a8a7cda1da43816d01c3a3a3b0c878baf181aaee34a9b0d846f37929c42115a70d7c1456d5e6c2e80e90850a7f9b9023b6fddc59b5d7997d153b05188e6";
            // $public_key_hex = $request->input('pubkey');
            // Log::error('keyHex length: ' . strlen($public_key_hex));

            // Convert the hex string to a binary format
            // $public_key_bin = hex2bin($public_key_hex);

            // Check if the public key is compressed or uncompressed
            // if (substr($public_key_hex, 0, 2) == "02" || substr($public_key_hex, 0, 2) == "03") {
            //     // If the public key is compressed, extract the x coordinate
            //     $x_bin = substr($public_key_bin, 1);
            //     $x = bin2hex($x_bin);

            //     echo "x coordinate: " . $x . "\n";
            // } else {
            //     // If the public key is uncompressed, extract both the x and y coordinates
            //     $x_bin = substr($public_key_bin, 1, 32);
            //     $x = bin2hex($x_bin);

            //     $y_bin = substr($public_key_bin, 33);
            //     $y = bin2hex($y_bin);

            //     echo "x coordinate: " . $x . "\n";
            //     echo "y coordinate: " . $y . "\n";
            // }

            // Log::error('x: ' . $x);
            // Log::error('y: ' . $y);
            // $adapter = \Mdanter\Ecc\EccFactory::getAdapter();
            // $generator = \Mdanter\Ecc\EccFactory::getNistCurves()->generator256();

            // // $keyHex = $request->input('pubkey');
            // $keyHex = '03d4e07f0b8ad4d8629d6f0e7f238628bb8f1236a956266b54c0346b586c6a8a6c';
            // // log the length of keyHex
            // Log::error('keyHex length: ' . strlen($keyHex));

            // // convert hex public key to point
            // // $curve = CurveFactory::getByName('secp256k1');
            // $math = new GmpMath();
            // $point = $math->hexDec($keyHex);
            // $generator->getPublicKeyFrom()

            // $keyData = \Mdanter\Ecc\Util\BinaryString::decodeHex($keyHex);

            // $x = substr($keyHex, 2, 64)

            // $point = $generator->getCurve()->getPoint(

            //     // $math->hexDec(),
            //     // $math->hexDec(substr($keyHex, 66))
            // );

            // $key = new PublicKey($adapter, $generator, $point);

            // Log::error('key??');
            // $key = new PublicKey($adapter, $generator, $point);
            // $publicKey = \Mdanter\Ecc\PublicKey\PublicKeyFactory::fromHex($keyHex);

            // $nonce = $request->input('nonce');
            // $proof = $request->input('proof');
            // $pubkey = $request->input('pubkey');

            // $adapter = \Mdanter\Ecc\EccFactory::getAdapter();
            // $generator = \Mdanter\Ecc\EccFactory::getNistCurves()->generator256();
            // $algorithm = 'sha256';

            // $math = new GmpMath();
            // $sigData = \Mdanter\Ecc\Util\BinaryString::decodeHex($sigHex);
            // $r = $math->readBytes(substr($sigData, 0, 32));
            // $s = $math->readBytes(substr($sigData, 32, 32));
            // $signature = new Signature($r, $s);




            // $publicKeyHex = $request->input('pubkey');
            // $publicKey = \Mdanter\Ecc\EccFactory::getSecgCurves()->getCurveByName('secp256k1')->getPublicKeyFrom(\Mdanter\Ecc\Math\GmpMath::getInstance(), \Mdanter\Ecc\Util\BinaryString::decodeHex($publicKeyHex));

            // $curve = new SecgCurve($adapter);
            // Log::info($curve);
            // $publicKey = $curve->getPublicKeyFrom(\Mdanter\Ecc\Math\GmpMath::getInstance(), \Mdanter\Ecc\Util\BinaryString::decodeHex($publicKeyHex));

            // $signatureHex = $request->input('proof');
            // $derSerializer = new \Mdanter\Ecc\Serializer\Signature\DerSignatureSerializer();
            // $signature = $derSerializer->parse(\Mdanter\Ecc\Util\BinaryString::decodeHex($signatureHex));


            // $hash = $request->input('hash');

            // Verify the proof was generated by the private key associated with the pubkey
            // $hash = hash('sha256', $nonce, true);
            // $verified = sodium_crypto_sign_verify_detached($proof, $hash, $pubkey);



            // if (!$verified) {
            //     return response()->json(['error' => 'Invalid proof'], 401);
            // }

            Log::info("YA");

            // $wut = sodium_crypto_sign_verify_detached(
            //     $request->input('proof'),
            //     $nonce,
            //     $request->input('pubkey')
            // );
            // Log::info('wut: ' . $wut);



            // $pubkey = "-----BEGIN PUBLIC KEY-----\n" . wordwrap($request->input('pubkey'), 64, "\n", true) . "\n-----END PUBLIC KEY-----\n";
            // $public_key = openssl_pkey_get_public($pubkey);
            // if ($public_key === false) {
            //     Log::error('key false.');
            //     return response()->json(['error' => 'key no good'], 444);
            //     // throw new ProofException();
            // }


            // $hash = hash('sha256', $nonce, true);
            // $pubkey = base64_decode($request->input('pubkey'));
            // $proof = hex2bin($request->input('proof'));
            // $verified = openssl_verify($hash, $proof, $pubkey, OPENSSL_ALGO_SHA256);

            // if ($verified !== 1) {
            //     return response()->json(['error' => 'Invalid proof'], 401);
            // }

            // $pubkey = $request->input('pubkey');
            // // dd($pubkey);
            // $proof = hex2bin($request->input('proof'));
            // $signature = "-----BEGIN PUBLIC KEY-----\n" . wordwrap($pubkey, 64, "\n", true) . "\n-----END PUBLIC KEY-----\n";
            // $public_key = openssl_pkey_get_public($signature);
            // // if ($public_key === false) {
            // //     Log::error('key false.');
            // //     Log::error('pubkey: ' . $pubkey);
            // //     Log::error('signature: ' . $signature);
            // //     throw new ProofException();
            // // }

            // $verified = openssl_verify($nonce, $proof, $pubkey, OPENSSL_ALGO_SHA256);

            // if ($verified !== 1) {
            //     return response()->json(['error' => 'Invalid proof'], 401);
            // }
        } catch (\Exception $e) {
            Log::error($e);
            // Log::error($pubkey);
            // throw new ProofException();
        }


        // $user = User::create([
        //     'pubkey' => '12345'
        // ]);
        // $token = $user->createToken('testo')->plainTextToken; // $request->device_name
        // return response()->json([
        //     'token' => $token
        // ]);
    }

    public function apiLoginOld(Request $request)
    {
        $request->validate([
            'pubkey' => 'required',
            'device_name' => 'required',
            'proof' => 'required',
        ]);

        // Validate the proof was generated by the private key associated with the pubkey
        // TODO

        $pubkey = $request->pubkey;
        $user = User::where('pubkey', $pubkey)->first();
        if (!$user) {
            // Create a user with this pubkey and log them in
            $user = User::create([
                'pubkey' => $pubkey
            ]);
        }

        return $user->createToken($request->device_name)->plainTextToken;
    }
}
